
**AI 辅助编程实践日志**
**项目名称:** MFC 轻量级多任务调度器
**开发日期:** 2025-12-04
**姓名:** 赵子锐
**专业:** 电子信息
**学号:** 20250313016Z
**IDE版本:** Visual Studio 2026

---

### 1. 项目初始化与环境配置 (Initialization)

**1.1 用户提问**

> "我需要做项目三，帮我从安装开始一步步设定。环境要求是 Windows 10/11 x64, VS2026。"

**1.2 AI 回答**
好的，我们需要确保你的开发环境支持 MFC 开发。

1. **环境检查**：请打开 Visual Studio Installer，修改你的 VS2026 安装，确保勾选了 **"C++ MFC for v143 build tools (x86 & x64)"** 组件。
2. **创建项目**：
* 打开 VS，选择 "Create a new project"。
* 搜索并选择 **"MFC App"**。
* **关键设置**：在 "Application Type" 中选择 **"Dialog based"**（基于对话框）。这符合课件中要求的“轻量级”和“控制台风格”，避免了文档视图（Doc-View）结构的过度复杂。


3. **核心文件结构规划**：
建议创建以下头文件：
* `ITask.h`: 所有任务的抽象基类。
* `ScheduledTask.h`: 包含执行时间等元数据的任务包装类。
* `LogWriter.h`: 用于 RAII 资源管理的文件日志类。



**1.3 Human Review & Implementation (人工审核与实现)**

* **审核**: 确认项目类型选择 "Dialog based" 正确。
* **操作**: 在配置管理器中将平台手动切换为 `x64` 以符合课件要求。

---

### 2. 核心架构设计

**2.1 用户提问**

> "下一步开始创建项目骨架。我们需要实现 TaskScheduler 单例和多线程调度。"

**2.2 AI 回答**
明白，这是核心部分。我们需要一个线程安全的单例调度器。这是 `TaskScheduler` 的代码实现方案：

* **Singleton**: 使用 `GetInstance()` 方法返回静态实例。
* 
**Priority Queue**: 使用 `std::priority_queue` 配合自定义比较器，构建一个最小堆，保证时间最早的任务在队首 。


* **Threading**: 定义 `std::thread workerThread` 作为后台工作线程，配合 `std::condition_variable` 进行任务等待。

**2.3 关键修正**

* **AI 原始代码**: `int intervalMs = topTask.interval.count();` (直接从 chrono 转换) 。
* **人工修正 (Warning C4244)**: 编译器提示从 `long long` 转换到 `int` 可能丢失数据。
* **修正代码**: `intervalMs = static_cast<int>(topTask.interval.count());`
* **反思**: AI 生成的代码虽然逻辑正确，但对类型安全（Type Safety）的细节处理有时不够严谨，需要人工介入消除警告。

---

### 3. 具体任务实现

**3.1 用户提问**

> "实现具体任务。"

**3.2 AI 回答**
好的，我们来具体化 `ITask` 接口。我为你准备了 `ConcreteTasks.h` 和 `TaskFactory.h`：

1. **Task B (矩阵运算)**: 这是一个模拟 CPU 密集型的任务。我在 `Execute` 函数中实现了一个 200 \times 200 的矩阵乘法循环。
2. **Task D (UI 提醒)**: 使用 `AfxMessageBox` 弹出一个简单的对话框。
3. **TaskFactory**: 我们使用简单工厂模式，根据传入的字符串（如 "TaskB", "TaskD"）返回对应的 `std::shared_ptr<ITask>`。

---

### 4. 观察者模式与 UI 联调

**4.1 用户提问**

> "我添加了代码，但是日志框是空白的，没有内容出现。而且出现了 E0265 错误，OnUpdateLog 不可访问。"

**4.2 AI 回答 (故障排查)**
这看起来是两个问题，我们逐一排查：

1. **E0265 错误**: 这是一个访问权限问题。MFC 的消息映射宏 `ON_MESSAGE` 需要访问你的处理函数，但你可能把 `afx_msg LRESULT OnUpdateLog` 定义在了 `private` 区域。请把它移到 `public` 或 `protected` 区域 。
2. **UI 空白**: 如果没有编译错误但 UI 不更新，通常是因为观察者没有注册。请检查你的 `OnInitDialog` 函数 。
3. **乱码风险**: 另外提醒一下，从 `std::string` 转换到 MFC 的 `CString` 时要注意字符集编码，建议使用 `CA2T` 宏。

**4.3 深度调试记录**

* **Fix 1 (权限问题)**:
* Before: 代码位于 `private:` 块中。
* After: 将 `OnUpdateLog` 显式移动到 `public:` 区域，编译通过。


* **Fix 2 (逻辑漏洞)**:
* 发现: `OnInitDialog` 中确实缺少 `AttachObserver(this)`。
* 修正: 手动补全该行代码，建立了 UI 与后台 Scheduler 的连接。
* 验证: 再次运行，日志框成功显示 "Scheduler Started"。



---

### 5. 需求对齐与功能补全

**5.1 用户提问**

> "排查一下项目三的要求是否都实现了？Task C 和 Task E 怎么加？"

**5.2 AI 回答**
我对照课件帮你做了一次代码审计，发现我们还遗漏了以下内容：

1. **Task C**: 这是一个网络任务，要求发送 HTTP GET 请求 (如 GitHub API)。
2. **Task E**: 这是一个统计任务，需要计算随机数的均值和方差。
3. **参数错误**: Task B 和 Task D 的当前执行间隔与课件要求不符。

**5.3 实现细节**

* **HTTP Task**: 我建议引入 `<afxinet.h>`，使用 MFC 自带的 `CInternetSession` 类来实现下载，并将结果写入 `zen.txt` 。
* **Stats Task**: 引入 `<numeric>` 和 `<random>` 库，我可以给你提供计算标准差的算法实现。
* **Parameter Tuning (参数校正)**:
* **Task B (矩阵)**: 修改为 `interval = 5000` (即 5秒)。
* **Task D (提醒)**: 修改为 `interval = 60000` (即 1分钟)。



---

### 6. 界面优化 (UI Polish)

**6.1 用户提问**

> "UI 界面太简陋，需要简单设计一下。"

**6.2 AI 回答**
即使是轻量级程序，良好的布局也很重要。建议进行以下修改：

1. **分区**: 使用 GroupBox 控件，将界面划分为“调度器控制”与“任务生成”两个区域，逻辑更清晰。
2. **ListBox 属性**: 请务必将 ListBox 的 `Sort` 属性设为 `False`，否则日志会按字母顺序乱排，而不是按时间顺序。同时开启 `Vertical Scroll` 以支持滚动查看。

---

### 7. 进阶功能：防死锁监控 (Advanced Feature: Deadlock Watchdog)

**7.1 User Prompt (需求变更)**

> "现在需要追加一个防死锁功能。"

**7.2 AI Response (方案设计)**
在 C++ 中，直接强制杀死（Kill）一个卡死的线程是非常危险的（会导致锁无法释放、资源泄露）。
我建议实现一个 **"看门狗 (Watchdog)"** 模式：

* **架构**: 增加一个独立的监控线程 `MonitorLoop`。
* **机制**: 工作线程在执行任务前进行“打卡”（记录时间戳），监控线程每秒检查一次，如果当前任务执行时间超过阈值（如 10秒），则判定为死锁并触发报警。

**7.3 Implementation & Diff (实现与修正)**

* **Thread Safety (线程安全)**:
为了防止数据竞争 (Data Race)，我们需要引入原子变量：
`std::atomic<long long> taskStartTime;`
`std::atomic<bool> isTaskRunning;`
* **Integration (集成)**:
在 `TaskScheduler::Start` 和 `Stop` 中添加代码，正确管理监控线程的生命周期，防止程序退出时监控线程抛出异常。
* **Test Verification (测试验证)**:
我为你编写一个 `DeadlockTask`（故意休眠 15秒）。
*结果*: 运行测试任务后，UI 日志栏在第 10 秒准确弹出了 `[DEADLOCK WARNING]` 红色警告，证明监控逻辑有效。

**7.4 Critical Thinking (技术反思)**

* **为什么不自动结束卡死的任务？**
如果强行 terminate 正在执行 `MatrixTask` 的线程，它可能正持有 `std::vector` 的内存锁或文件句柄。强制杀死会导致堆损坏或死锁扩散。在 C++ 桌面开发中，"检测并报警 (Detect & Alert)" 优于 "自动恢复"，这体现了对异常安全 (Exception Safety) 和资源管理的严谨态度。



### 8. 补全遗漏功能：Task A 文件备份 (Feature Completion: File Backup)

**8.1 User Prompt**

> "这个 Task A 是不是没用实现？现在我需要你再实现文件备份，要求压缩 C:\Data 到 D:\Backup。"

**8.2 AI Response & Analysis**
是的，之前我们暂时跳过了这个任务。关于“压缩”功能：

* **分析**: C++ 标准库本身不支持 ZIP 压缩，引入 zlib 等第三方库对于这个轻量级项目来说太重了。
* **建议**: 我建议使用 `std::system()` 调用 Windows 内置的 **PowerShell** 命令 `Compress-Archive`。这是最轻量且无需额外依赖的方案。

**8.3 Implementation (代码实现)**
我为你生成了如下代码逻辑：

1. **System Call**: 使用 `std::system()` 执行指令。
2. **Command Construction**: 动态构建带时间戳的命令字符串：
`Compress-Archive -Path 'C:\Data' -DestinationPath 'D:\Backup\backup_20251204.zip' -Force`
3. **Error Handling**: 我们会检查 `system()` 的返回值，并在失败时抛出异常，让 Scheduler 捕获并记录日志。

**8.4 Verification (验证)**

* 手动在 C 盘创建 `Data` 目录进行测试。
* 运行任务后，成功在 D 盘 `Backup` 目录下生成了 `.zip` 压缩包。